package engine;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.awt.*;
import java.util.ArrayList;

public class Gate extends PhysicalEntity{
    // paths to insert enemies in
    private ArrayList<Path> paths;

    /**
     * Get the paths of the Gate
     *
     * @return returns an ArrayList<Path>
     */
    public ArrayList<Path> getPaths() {
        return paths;
    }

    // a queue to put incoming enemies in
    private ArrayList<AliveEnemyUnit> enemyQueue;

    /**
     * Constructs the gate
     * @param pathNode the node from the xml file
     * @param world the world to put the gate in
     * @throws Exception if the xml has problem some exception will occur
     */
    public Gate(NodeList pathNode, World world) throws Exception {
        super(world);
        //SET GATE CELLS
        generatePaths(pathNode);
        enemyQueue = new ArrayList<>();
    }

    /**
     * This method just adds enemy that is generated by Wave to the Queue
     */
    public void addEnemy(AliveEnemyUnit enemy) {
        enemyQueue.add(enemy);
    }

    /**
     * This method is called when an enemy unit lefts first cell and enters second
     * In this method another enemy that is in queue for entering the map, will start to move and enter first cell of map
     * <p>
     * Attention: When first enemy unit of each path is waiting to enter the map there is no enemy before, so this method is not called by an Enemy in this condition
     * it is called by Wave after adding enemies to the gate
     */
    public void pathEntranceGotFree(Path path) {
        if (!paths.contains(path))
            throw new IllegalArgumentException("me: This path doesn't exist in gate pathList");

        AliveEnemyUnit enemy = enemyQueue.get(0);
        enemyQueue.remove(0);
        enemy.enterTheMap(path);
    }

    /**
     * Generate paths based on an xml node
     * @param pathsElements The node list of paths in the xml file
     */
    private void generatePaths(NodeList pathsElements) {
        // init paths
        paths = new ArrayList<>();

        // for each path element in the map file
        for (int i = 0; i < pathsElements.getLength(); i++) {
            // current pathnode
            Node pathNode = pathsElements.item(i);
            // get directions from the map file, in u, l, r, d format
            String directions = pathNode.getTextContent();

            // set starting point of the path
            int x = Integer.parseInt(pathNode.getAttributes().getNamedItem("start_x").getTextContent());
            int y = Integer.parseInt(pathNode.getAttributes().getNamedItem("start_y").getTextContent());
            Point start = new Point(x, y);
            // temporary list for path cells
            ArrayList<Cell> pathCells = new ArrayList<>();
            // add the starting cell
            pathCells.add(getWorld().getMap().getCells().get(start));

            // for each direction
            for (int j = 0; j < directions.length(); j++) {

                // current direction
                char direction = directions.charAt(j);
                switch (direction) {
                    // left
                    case 'l':
                        x--;
                        break;
                    // right
                    case 'r':
                        x++;
                        break;
                    // up
                    case 'u':
                        y--;
                        break;
                    // down
                    case 'd':
                        y++;
                        break;
                }
                // add current cell to cells
                pathCells.add(getWorld().getMap().getCells().get(new Point(x, y)));
            }
            // create path from cells
            Path path = new Path(getWorld(), pathCells);
            // add the path to the paths
            paths.add(path);
        }
    }

    /**
     * Here the gate puts the enemies in paths
     */
    @Override
    public void timerTick() {
        for (AliveEnemyUnit enemyUnit : enemyQueue) {
            for (Path path :
                    paths) {
                if (path.isEntranceFree()) {
                    enemyUnit.enterTheMap(path);
                    break;
                }
            }
        }
    }
}
