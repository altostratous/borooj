package logic.physics;

import logic.controllers.World;
import logic.models.Cell;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.awt.*;
import java.util.ArrayList;

public class Gate extends PhysicalEntity {
    // paths to insert enemies in
    private ArrayList<Path> paths;

    /**
     * Get the paths of the Gate
     *
     * @return returns an ArrayList<Path>
     */
    public ArrayList<Path> getPaths() {
        return paths;
    }

    // a queue to put incoming enemies in
    private ArrayList<AliveEnemyUnit> enemyQueue;

    /**
     * Constructs the gate
     * @param pathNodes the node from the xml file
     * @param world the world to put the gate in
     * @throws Exception if the xml has problem some exception will occur
     */
    public Gate(NodeList pathNodes, World world) throws Exception {
        super(world);

        // SET GATE CELLS
        // for each path element in the map file
        ArrayList<Cell> cells = new ArrayList<>();
        for (int i = 0; i < pathNodes.getLength(); i++) {
            // current pathnode
            Node pathNode = pathNodes.item(i);

            // set starting point of the path
            int x = Integer.parseInt(pathNode.getAttributes().getNamedItem("start_x").getTextContent());
            int y = Integer.parseInt(pathNode.getAttributes().getNamedItem("start_y").getTextContent());

            cells.add(world.getMap().getCells().get(new Point(x, y)));
        }
        setCells(cells);
        generatePaths(pathNodes);
        enemyQueue = new ArrayList<>();
    }

    /**
     * This method just adds enemy that is generated by Wave to the Queue
     */
    public void addEnemy(AliveEnemyUnit enemy) {
        enemyQueue.add(enemy);
    }

//    /**
//     * This method is called when an enemy unit lefts first cell and enters second
//     * In this method another enemy that is in queue for entering the map, will start to move and enter first cell of map
//     * <p>
//     * Attention: When first enemy unit of each path is waiting to enter the map there is no enemy before, so this method is not called by an Enemy in this condition
//     * it is called by Wave after adding enemies to the gate
//     */
//    public void pathEntranceGotFree(Path path) {
//        if (!paths.contains(path))
//            throw new IllegalArgumentException("me: This path doesn't exist in gate pathList");
//
//        AliveEnemyUnit enemy = enemyQueue.get(0);
//        enemyQueue.remove(0);
//        enemy.enterTheMap(path);
//    }

    /**
     * Generate paths based on an xml node
     * @param pathsElements The node list of paths in the xml file
     */
    private void generatePaths(NodeList pathsElements) {
        // init paths
        paths = new ArrayList<>();

        // for each path element in the map file
        for (int i = 0; i < pathsElements.getLength(); i++) {
            // current pathnode
            Node pathNode = pathsElements.item(i);
            // get directions from the map file, in u, l, r, d format
            String directions = pathNode.getTextContent();

            // set starting point of the path
            int x = Integer.parseInt(pathNode.getAttributes().getNamedItem("start_x").getTextContent());
            int y = Integer.parseInt(pathNode.getAttributes().getNamedItem("start_y").getTextContent());
            Point start = new Point(x, y);
            // temporary list for path cells
            ArrayList<Cell> pathCells = new ArrayList<>();
            // add the starting cell
            pathCells.add(getWorld().getMap().getCells().get(start));

            // for each direction
            for (int j = 0; j < directions.length(); j++) {

                // current direction
                char direction = directions.charAt(j);
                switch (direction) {
                    // left
                    case 'l':
                        x--;
                        break;
                    // right
                    case 'r':
                        x++;
                        break;
                    // up
                    case 'u':
                        y--;
                        break;
                    // down
                    case 'd':
                        y++;
                        break;
                }
                // add current cell to cells
                pathCells.add(getWorld().getMap().getCells().get(new Point(x, y)));
            }
            // create path from cells
            Path path = new Path(getWorld(), pathCells, directions);
            // add the path to the paths
            paths.add(path);
        }
    }

//    /**
//     * It is necessary for using gate, this method call first round enemy entrance
//     */
//    public void start() {
//        for (AliveEnemyUnit unit :
//                enemyQueue) {
//            getWorld().getTimer().schedule(unit.getTimerTask(), 0, unit.getInterval());
//        }
//    }

    /**
     * Here the gate puts the enemies in paths
     */
    @Override
    public void timerTick() {
        for (int i = enemyQueue.size() - 1; i >= 0; i--) {
            AliveEnemyUnit enemyUnit = enemyQueue.get(i);
            for (Path path :
                    paths) {
                if (path.isEntranceFree()) {
                    enemyUnit.enterTheMap(path);
                    enemyQueue.remove(i);
                    break;
                }
            }
        }
    }
}
